---
phase: 03-core-infrastructure
plan: 02
type: execute
depends_on: ["03-01"]
files_modified: [src/lib/config.ts, src/lib/sanity-client.ts]
---

<objective>
Create the shared Sanity client module and centralized configuration that all pipeline scripts (Phases 4-10) will import.

Purpose: Eliminate the pattern of every script creating its own Sanity client. Provide a single, tested module that handles environment loading, client creation, and connection validation — so pipeline scripts just import and use.
Output: Working shared Sanity client module (src/lib/sanity-client.ts) and config module (src/lib/config.ts), verified against the live Sanity API.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-plan.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-core-infrastructure/03-01-SUMMARY.md

# Existing Sanity client pattern (from 637 scripts):
# ```typescript
# import { createClient } from '@sanity/client'
# import 'dotenv/config'
# const client = createClient({
#   projectId: process.env.SANITY_PROJECT_ID,
#   dataset: process.env.SANITY_DATASET,
#   useCdn: false,
#   token: process.env.SANITY_API_TOKEN,
#   apiVersion: '2024-01-01',
# })
# ```
# - .env has: SANITY_PROJECT_ID=wwmm9rbb, SANITY_DATASET=production, SANITY_API_VERSION=2024-01-01, SANITY_API_TOKEN=...
# - Existing scripts use apiVersion '2024-01-01' consistently
# - useCdn: false for all write operations
# - Phase 2 established process.env pattern with fallback: process.env.SANITY_PROJECT_ID || 'wwmm9rbb'

**Tech stack available:** @sanity/client ^7.2.1, dotenv ^16.5.0, TypeScript 5, ESM
**Established patterns:** dotenv/config import, process.env with fallbacks, createClient from @sanity/client
**Constraining decisions:**
- All credentials via environment variables
- Fallback project ID: wwmm9rbb
- Dataset: production
- API version: 2024-01-01
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create config module and shared Sanity client</name>
  <files>src/lib/config.ts, src/lib/sanity-client.ts</files>
  <action>Create src/lib/config.ts:
  - Import dotenv/config at the top (loads .env automatically)
  - Export a `config` object with typed fields:
    - sanity.projectId: from SANITY_PROJECT_ID env (fallback: 'wwmm9rbb')
    - sanity.dataset: from SANITY_DATASET env (fallback: 'production')
    - sanity.apiVersion: from SANITY_API_VERSION env (fallback: '2024-01-01')
    - sanity.token: from SANITY_API_TOKEN env (throw error if missing — token is required for mutations)
  - Validate required env vars on import: if SANITY_API_TOKEN is missing, throw a clear error with instructions ("Set SANITY_API_TOKEN in .env file")
  - Export the config type for use in other modules

  Create src/lib/sanity-client.ts:
  - Import config from ./config.ts
  - Import createClient from @sanity/client
  - Create and export a singleton `sanityClient` using config values with useCdn: false
  - Export a `getClient()` function that returns the singleton (for cases where lazy initialization is preferred)
  - Do NOT add retry logic here — that belongs in the error handling module (Plan 03-03)
  - Do NOT add caching — useCdn: false is correct for a write-heavy migration pipeline

  Why singleton: Pipeline scripts import the same client instance, avoiding connection overhead. The migration runs as a single process, not a server — one client is correct.
  Why no retry: Separation of concerns. Error handling (Plan 03-03) will wrap operations with retry logic at the call site, not in the client itself.</action>
  <verify>`npx tsc --noEmit` passes with 0 errors. Importing the module does not throw (env vars exist in .env).</verify>
  <done>src/lib/config.ts exports typed config with env validation. src/lib/sanity-client.ts exports a working Sanity client singleton. TypeScript compiles without errors.</done>
</task>

<task type="auto">
  <name>Task 2: Verify client works against live Sanity API</name>
  <files>src/lib/sanity-client.ts</files>
  <action>Create a small inline verification script (do NOT create a permanent test file — just run via tsx):

  Run via bash: `npx tsx -e "import { sanityClient } from './src/lib/sanity-client.js'; const count = await sanityClient.fetch('count(*[_type == \"servicePage\"])'); console.log('servicePage count:', count);"`

  If the inline approach has issues with ESM, create a temporary file `src/verify-client.ts`, run it, then delete it.

  Expected result: Should print a count around 1419 (996 DE + 422 EN + a few others). Any number > 0 confirms the client is connecting and querying correctly.

  Also verify a GROQ query that filters by language to confirm query capability:
  `count(*[_type == "servicePage" && language == "de"])` — should return ~996.

  If either query fails, debug: check .env exists at project root, check dotenv loads correctly from src/lib/config.ts, check token is valid.</action>
  <verify>Client successfully queries Sanity. servicePage count > 0. German page count ~996.</verify>
  <done>Shared Sanity client connects to production, executes GROQ queries, returns expected data. Client module is ready for use by all pipeline phases.</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] src/lib/config.ts exists with typed config and env validation
- [ ] src/lib/sanity-client.ts exists with singleton client export
- [ ] `npx tsc --noEmit` passes
- [ ] Client successfully queries live Sanity API (servicePage count > 0)
- [ ] Missing SANITY_API_TOKEN throws clear error (not cryptic undefined)
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- Sanity client module works end-to-end
- Config validates required environment variables
- No temporary files left behind
</success_criteria>

<output>
After completion, create `.planning/phases/03-core-infrastructure/03-02-SUMMARY.md`
</output>
