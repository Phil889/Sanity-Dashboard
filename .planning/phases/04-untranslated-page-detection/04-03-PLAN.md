---
phase: 04-untranslated-page-detection
plan: 03
type: execute
depends_on: ["04-01", "04-02"]
files_modified: [src/tools/generate-queue.ts, src/data/translation-queue.json]
---

<objective>
Build a CLI tool that merges Sanity detection results with local file scan to produce a prioritized translation queue.

Purpose: Create a single ordered list of pages to translate, factoring in hierarchy (parents first) and existing local work.
Output: `src/tools/generate-queue.ts` — CLI tool producing `src/data/translation-queue.json`.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-plan.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Upstream plan summaries (will exist at execution time):
@.planning/phases/04-untranslated-page-detection/04-01-SUMMARY.md
@.planning/phases/04-untranslated-page-detection/04-02-SUMMARY.md

# Infrastructure to use:
@src/lib/config.ts
@src/lib/sanity-client.ts
@src/lib/errors.ts
@src/lib/logger.ts

# Upstream tools (will exist at execution time):
@src/tools/detect-untranslated.ts
@src/tools/scan-local-translations.ts

**Tech stack available:** @sanity/client ^7.2.1, Node.js fs/promises, tsx ^4.0.0, TypeScript 5 (ESM)
**Established patterns:** singleton sanityClient, withRetry, logger, CLI arg parsing, JSON report output

**Constraining decisions:**
- Decision #1: `translation.metadata` is authoritative
- Decision #4: Tracker unreliable; Sanity queries are source of truth
- From 01-04: Parents must exist before children (parent._ref must resolve)
- From 01-04: English pages reference parent pages by _id
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create generate-queue.ts CLI tool</name>
  <files>src/tools/generate-queue.ts, src/data/.gitkeep</files>
  <action>
Create `src/tools/generate-queue.ts` — a CLI tool that produces a prioritized translation queue.

**Input sources (2 approaches — tool supports both):**

Approach A — Run upstream tools internally:
- Import and invoke the detection logic from `detect-untranslated.ts`
- Import and invoke the scan logic from `scan-local-translations.ts`
- This is the default: `npx tsx src/tools/generate-queue.ts`

Approach B — Accept pre-generated JSON files:
- `--detection <path>` flag: path to detection report JSON (from 04-01)
- `--local-scan <path>` flag: path to local scan report JSON (from 04-02)
- This allows reuse of cached results

**Implementation approach:**

To enable both approaches, the detection and local scan tools should export their core logic as functions (not just CLI entry points). Refactor if needed:
- `detect-untranslated.ts` should export `async function runDetection(): Promise<DetectionReport>`
- `scan-local-translations.ts` should export `async function runLocalScan(): Promise<LocalScanReport>`
- Both files keep their CLI `if (import.meta.url ...)` entry point for standalone use

**Priority algorithm:**

1. **Hierarchy depth** (lower depth = higher priority):
   - Use the `parentRef` and `topLevelRef` fields from detection results
   - Pages with no `parentRef` (root-level pages) → depth 0 → highest priority
   - Pages whose `parentRef` matches a known German page → compute depth
   - Query Sanity for the page hierarchy if needed:
     ```
     *[_type == "servicePage" && language == "de"]{ _id, "parentRef": parent._ref }
     ```
   - Parents must be translated before their children (parent._ref must resolve to an English page)

2. **Local file status** (existing work gets priority boost):
   - Pages with existing `create-*-en.ts` or `import-*-en.ts` files → flag as `hasLocalFile: true`
   - These may already be translated and just need upload/verification
   - Sort these to the top within each depth level

3. **Alphabetical** (tiebreaker within same depth and local status):
   - Sort by slug alphabetically

**Queue output structure:**
```typescript
interface TranslationQueue {
  generatedAt: string;
  summary: {
    totalPages: number;       // total pages in queue
    withLocalFiles: number;   // pages that have existing local translation files
    withoutLocalFiles: number; // pages needing fresh translation
    byDepth: Record<number, number>; // count per hierarchy depth
  };
  queue: Array<{
    position: number;          // 1-based position in queue
    germanId: string;          // German page _id
    title: string;             // German page title
    slug: string;              // German page slug
    depth: number;             // hierarchy depth (0 = root)
    parentRef: string | null;  // German parent _id
    topLevelRef: string | null; // top-level category _id
    hasLocalFile: boolean;     // whether local translation file exists
    localFile: string | null;  // filename if exists
    localCompleteness: string | null; // 'full', 'main-only', 'faqs-only', 'source-only', or null
  }>;
}
```

**Output:**
- Default: writes to `src/data/translation-queue.json`
- `--output <path>` flag: write to custom path
- Human-readable summary always printed to console
- Create `src/data/` directory if it doesn't exist (use `mkdir -p` equivalent)

**CLI flags:**
- `--detection <path>`: use pre-generated detection JSON
- `--local-scan <path>`: use pre-generated local scan JSON
- `--output <path>`: custom output path (default: `src/data/translation-queue.json`)
- `--limit <N>`: only include first N pages in queue (for testing)

**Implementation notes:**
- ESM imports with `.js` extension
- Use `withRetry` for any Sanity queries (hierarchy lookup)
- Use `logger.search()`, `logger.stats()`, `logger.success()`
- Use `logger.progress()` when computing hierarchy depths
- Add npm script `"generate-queue"` to package.json: `"tsx src/tools/generate-queue.ts"`
  </action>
  <verify>npx tsc --noEmit (no TypeScript errors)</verify>
  <done>src/tools/generate-queue.ts exists, compiles cleanly, npm script "generate-queue" added to package.json, src/data/ directory created</done>
</task>

<task type="auto">
  <name>Task 2: Generate translation queue from live data</name>
  <files>src/data/translation-queue.json</files>
  <action>
Run the queue generator against live Sanity data + local filesystem to produce the initial translation queue.

Run: `npx tsx src/tools/generate-queue.ts`

**Verify the output:**
1. Queue contains ~584 pages (matching detection count)
2. Root-level pages (depth 0) appear first
3. Parents appear before their children (depth N before depth N+1)
4. Pages with local files are flagged correctly
5. `translation-queue.json` is valid JSON
6. Summary counts match: totalPages = withLocalFiles + withoutLocalFiles

**Spot-check a few entries:**
- Check 2-3 root-level pages have depth 0
- Check a child page has depth > 0 and its parentRef matches a known page
- Check a page with a known local file (e.g., one of the kritis-* or mifid-* slugs) has `hasLocalFile: true`

If any issues found, fix the tool and re-run.

**After verification, also run the upstream tools standalone to ensure they still work independently:**
- `npx tsx src/tools/detect-untranslated.ts --json --output src/data/detection-report.json`
- `npx tsx src/tools/scan-local-translations.ts --json --output src/data/local-scan-report.json`

This produces 3 data files in `src/data/` for future phases to consume.
  </action>
  <verify>cat src/data/translation-queue.json is valid JSON with ~584 entries, ordered by depth then local status then slug</verify>
  <done>translation-queue.json exists with ~584 entries, correctly prioritized, all 3 data files generated in src/data/</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npx tsc --noEmit` passes with zero errors
- [ ] `npx tsx src/tools/generate-queue.ts` completes and outputs queue
- [ ] `src/data/translation-queue.json` has ~584 entries
- [ ] Queue is ordered: depth 0 first, then depth 1, etc.
- [ ] Pages with local files flagged correctly
- [ ] All 3 npm scripts work: `detect`, `scan-local`, `generate-queue`
- [ ] Phase 4 complete: all German pages detected, prioritized, queued
</verification>

<success_criteria>

- Queue merges Sanity detection with local file scan
- Priority order respects hierarchy (parents before children)
- Pages with existing local files are flagged
- Machine-readable output for Phase 5 consumption
- All tasks completed, Phase 4 complete
</success_criteria>

<output>
After completion, create `.planning/phases/04-untranslated-page-detection/04-03-SUMMARY.md`
</output>
