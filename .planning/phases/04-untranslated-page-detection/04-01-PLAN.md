---
phase: 04-untranslated-page-detection
plan: 01
type: execute
depends_on: []
files_modified: [src/tools/detect-untranslated.ts]
---

<objective>
Build a CLI tool that queries Sanity to detect all German servicePages and their English translation status using `translation.metadata` documents.

Purpose: Provide accurate, live detection of which pages need translation — replacing the unreliable manual tracker.
Output: `src/tools/detect-untranslated.ts` — CLI tool producing a full translation status report.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-plan.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Key prior summaries:
@.planning/phases/01-audit-assessment/01-04-SUMMARY.md
@.planning/phases/03-core-infrastructure/03-02-SUMMARY.md
@.planning/phases/03-core-infrastructure/03-03-SUMMARY.md

# Infrastructure to use:
@src/lib/config.ts
@src/lib/sanity-client.ts
@src/lib/errors.ts
@src/lib/logger.ts

# Existing tool for pattern reference:
@src/tools/faq-batch-runner.ts

**Tech stack available:** @sanity/client ^7.2.1, dotenv ^16.5.0, tsx ^4.0.0, TypeScript 5 (ESM)
**Established patterns:** singleton sanityClient, withRetry for API calls, logger with emoji prefixes, CLI arg parsing via process.argv

**Constraining decisions:**
- Decision #1: `translation.metadata` is authoritative for i18n linking (NOT `__i18n_base`)
- Decision #4: Tracker is unreliable; use Sanity queries for status
- Decision #10: Shared Sanity client singleton
- Decision #12: withRetry exponential backoff for all retryable operations
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create detect-untranslated.ts CLI tool</name>
  <files>src/tools/detect-untranslated.ts</files>
  <action>
Create `src/tools/detect-untranslated.ts` — a CLI tool that detects all German servicePages and their English translation status.

**GROQ Queries (2 queries, cross-referenced in code):**

1. Fetch all German servicePages:
```
*[_type == "servicePage" && language == "de"]{
  _id, title, "slug": slug.current,
  "parentRef": parent._ref,
  "topLevelRef": references.topLevelParent._ref
}
```

2. Fetch all translation.metadata documents for servicePages:
```
*[_type == "translation.metadata" && "servicePage" in schemaTypes]{
  _id,
  "deRef": translations[_key == "de"].value._ref,
  "enRef": translations[_key == "en"].value._ref
}
```

**Cross-reference logic:**
- Build a Map from German `_id` → metadata entry
- For each German page, look up its metadata:
  - If metadata exists AND has both `deRef` and `enRef` → **translated**
  - If metadata exists but `enRef` is empty/null/undefined → **metadata-only** (no EN doc linked)
  - If no metadata at all → **untranslated**
- Also track: metadata docs where `enRef` points to a non-existent doc → **broken-ref** (for reporting only)

**Also detect floating English pages:**
3. Fetch all English servicePages:
```
*[_type == "servicePage" && language == "en"]{ _id, title, "slug": slug.current }
```
- English pages whose `_id` does NOT appear as `enRef` in any metadata → **floating**

**Output format:**
- Default: human-readable summary with counts and category breakdown
- `--json` flag: full JSON report to stdout with arrays for each category
- `--json --output <path>` flag: write JSON to file instead of stdout

**JSON report structure:**
```typescript
interface DetectionReport {
  timestamp: string;
  summary: {
    totalGerman: number;
    translated: number;
    untranslated: number;
    metadataOnly: number;
    floatingEnglish: number;
    brokenRefs: number;
  };
  untranslated: Array<{ _id: string; title: string; slug: string; parentRef: string; topLevelRef: string }>;
  translated: Array<{ _id: string; title: string; slug: string; enDocId: string }>;
  metadataOnly: Array<{ _id: string; title: string; metadataId: string }>;
  floatingEnglish: Array<{ _id: string; title: string; slug: string }>;
  brokenRefs: Array<{ metadataId: string; deRef: string; enRef: string }>;
}
```

**CLI structure:**
- Follow same pattern as `faq-batch-runner.ts`: imports at top, types, main async function, process.argv parsing
- Use `logger.search()` for query messages, `logger.stats()` for counts, `logger.success()` for completion
- Use `withRetry` for both GROQ queries
- Handle `--json`, `--output <path>` flags
- Add npm script `"detect"` to package.json: `"tsx src/tools/detect-untranslated.ts"`

**Important:**
- Do NOT use `__i18n_base` or `__i18n_refs` for detection — these are legacy and unreliable
- ESM imports must use `.js` extension (e.g., `from '../lib/sanity-client.js'`)
- Sort untranslated pages alphabetically by slug for consistent output
  </action>
  <verify>npx tsc --noEmit (no TypeScript errors)</verify>
  <done>src/tools/detect-untranslated.ts exists, compiles cleanly, npm script "detect" added to package.json</done>
</task>

<task type="auto">
  <name>Task 2: Verify detection against live Sanity API</name>
  <files>src/tools/detect-untranslated.ts</files>
  <action>
Run the detection tool against the live Sanity API and verify results match audit expectations.

**Expected counts from Phase 1 audit (01-04):**
- Total German pages: 996
- Translated (with EN link in translation.metadata): ~415
- Untranslated (no EN translation): ~584
- Floating English pages: ~15
- Broken refs in translation.metadata: ~5
- Metadata-only (DE in metadata but no EN): ~2

Run: `npx tsx src/tools/detect-untranslated.ts`
Then: `npx tsx src/tools/detect-untranslated.ts --json`

Verify:
1. Summary counts are in expected range (allow ±5 for any changes since audit)
2. Total German = translated + untranslated + metadataOnly (should equal ~996)
3. JSON output is valid and contains all category arrays
4. `--output` flag writes file correctly

If counts differ significantly from audit (>10 difference), investigate with targeted GROQ queries and note the delta in the summary.
  </action>
  <verify>npx tsx src/tools/detect-untranslated.ts runs without errors and reports counts close to audit expectations (996 DE, ~584 untranslated, ~15 floating)</verify>
  <done>Detection tool runs against live API, counts verified within expected range, JSON output is valid</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npx tsc --noEmit` passes with zero errors
- [ ] `npx tsx src/tools/detect-untranslated.ts` produces human-readable summary
- [ ] `npx tsx src/tools/detect-untranslated.ts --json` produces valid JSON
- [ ] Summary counts match audit expectations (±5 tolerance)
- [ ] npm script `detect` works: `npm run detect`
</verification>

<success_criteria>

- Detection tool queries live Sanity and categorizes all German pages
- Counts match audit expectations (996 DE, ~584 untranslated, ~15 floating)
- JSON output is machine-readable for downstream tools (04-03)
- No TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/04-untranslated-page-detection/04-01-SUMMARY.md`
</output>
