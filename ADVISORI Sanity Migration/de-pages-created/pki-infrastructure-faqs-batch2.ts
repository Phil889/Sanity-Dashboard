import 'dotenv/config'
import { createClient } from '@sanity/client'

// Create client with direct credentials
const client = createClient({
  projectId: 'wwmm9rbb',
  dataset: 'production',
  apiVersion: '2024-02-14',
  token: process.env.SANITY_API_TOKEN,
  useCdn: false,
})

// Helper function to generate unique keys
function generateKey(prefix: string, index: number): string {
  return `${prefix}_${Date.now()}_${index}`
}

const run = async () => {
  try {
    console.log('Updating PKI Infrastructure page with FAQ batch 2...')
    
    // First, get the existing document
    console.log('Fetching existing document...')
    const existingDoc = await client.fetch('*[_id == $id][0]', { id: 'pki-infrastructure' })
    
    if (!existingDoc) {
      throw new Error('Document "pki-infrastructure" not found')
    }
    
    // Create new FAQs for certificate management and lifecycle
    const newFaqs = [
      {
        _type: 'object',
        _key: generateKey('faq', 5),
        question: 'Welche Standards und Protokolle sind f√ºr PKI-Implementierungen relevant und wie werden sie angewendet?',
        answer: "PKI-Implementierungen basieren auf einer Vielzahl internationaler Standards und Protokolle, die Interoperabilit√§t, Sicherheit und Compliance gew√§hrleisten. Die korrekte Anwendung dieser Standards ist entscheidend f√ºr den Erfolg und die Akzeptanz von PKI-Systemen in heterogenen IT-Umgebungen.\n\nüìú X.509 Certificate Standards:\n‚Ä¢ X.509 v3 Certificate Format definiert Struktur und Inhalt digitaler Zertifikate mit Erweiterungen f√ºr spezielle Anwendungsf√§lle\n‚Ä¢ Certificate Extensions erm√∂glichen zus√§tzliche Funktionalit√§ten wie Key Usage, Extended Key Usage und Subject Alternative Names\n‚Ä¢ Certificate Revocation Lists (CRL) v2 standardisieren Format und Verteilung von Widerrufsinformationen\n‚Ä¢ Attribute Certificates (AC) erweitern traditionelle Public-Key-Zertifikate um Autorisierungsinformationen\n‚Ä¢ Proxy Certificates erm√∂glichen delegierte Authentifizierung in Grid-Computing-Umgebungen\n\nüîê Kryptographische Standards:\n‚Ä¢ PKCS (Public-Key Cryptography Standards) Familie definiert kryptographische Datenformate und Algorithmen\n‚Ä¢ PKCS#1 spezifiziert RSA-Kryptographie-Implementierung und Padding-Verfahren\n‚Ä¢ PKCS#7/CMS (Cryptographic Message Syntax) standardisiert signierte und verschl√ºsselte Nachrichten\n‚Ä¢ PKCS#10 definiert Certificate Request Syntax f√ºr Zertifikatsanforderungen\n‚Ä¢ PKCS#11 bietet plattformunabh√§ngige API f√ºr Hardware Security Modules\n‚Ä¢ PKCS#12 erm√∂glicht portablen Transport von Private Keys und Zertifikaten\n\nüåê PKI-Management-Protokolle:\n‚Ä¢ Certificate Management Protocol (CMP) standardisiert PKI-Management-Operationen zwischen Clients und CAs\n‚Ä¢ Certificate Request Message Format (CRMF) definiert strukturierte Zertifikatsanforderungen\n‚Ä¢ Simple Certificate Enrollment Protocol (SCEP) erm√∂glicht automatische Zertifikatserneuerung\n‚Ä¢ Enrollment over Secure Transport (EST) bietet moderne RESTful PKI-Management-Schnittstelle\n‚Ä¢ Online Certificate Status Protocol (OCSP) erm√∂glicht Echtzeit-Zertifikatsstatus-Abfragen\n\nüèóÔ∏è Trust und Path Validation Standards:\n‚Ä¢ RFC 5280 definiert Internet X.509 Public Key Infrastructure Certificate und CRL Profile\n‚Ä¢ Path Validation Algorithms (RFC 5280) spezifizieren Vertrauensketten-Validierung\n‚Ä¢ Policy Framework Standards erm√∂glichen Certificate Policy und Certification Practice Statement\n‚Ä¢ Name Constraints Extensions beschr√§nken G√ºltigkeitsbereiche von Intermediate CAs\n‚Ä¢ Policy Mapping erm√∂glicht √úbersetzung zwischen verschiedenen Certificate Policies\n\nüîí Security und Compliance Standards:\n‚Ä¢ Common Criteria (ISO/IEC 15408) bietet Framework f√ºr PKI-Sicherheitsbewertung\n‚Ä¢ FIPS 140-2 definiert Sicherheitsanforderungen f√ºr kryptographische Module\n‚Ä¢ FIPS 186-4 spezifiziert Digital Signature Standard (DSS) f√ºr PKI-Anwendungen\n‚Ä¢ Suite B Cryptography definiert NSA-empfohlene kryptographische Algorithmen\n‚Ä¢ Elliptic Curve Cryptography Standards (FIPS 186-4, RFC 5480) f√ºr moderne PKI-Implementierungen\n\nüìã Industry-spezifische Standards:\n‚Ä¢ WebTrust for Certification Authorities definiert Audit-Kriterien f√ºr kommerzielle CAs\n‚Ä¢ CA/Browser Forum Baseline Requirements spezifizieren SSL/TLS-Zertifikatsanforderungen\n‚Ä¢ ETSI Standards (EN 319 401-403) f√ºr European Trust Service Providers\n‚Ä¢ Federal PKI (FPKI) Standards f√ºr US-Regierungs-PKI-Systeme\n‚Ä¢ ICAO PKI Standards f√ºr Machine Readable Travel Documents\n\nüõ†Ô∏è Implementation und Integration Standards:\n‚Ä¢ LDAP (RFC 4511) f√ºr PKI-Directory-Services und Zertifikatsverteilung\n‚Ä¢ DNS-based Authentication of Named Entities (DANE) f√ºr DNS-integrierte PKI\n‚Ä¢ Certificate Transparency (RFC 6962) f√ºr √∂ffentliche Zertifikats-Logs\n‚Ä¢ HTTP Public Key Pinning (HPKP) f√ºr Web-PKI-Sicherheit\n‚Ä¢ JSON Web Token (JWT) und JSON Web Signature (JWS) f√ºr moderne PKI-Anwendungen\n\n‚ö° Emerging Standards und Future Directions:\n‚Ä¢ Post-Quantum Cryptography Standards f√ºr quantenresistente PKI\n‚Ä¢ Blockchain-based PKI Standards f√ºr dezentrale Vertrauensmodelle\n‚Ä¢ IoT PKI Standards f√ºr skalierbare Device-Authentifizierung\n‚Ä¢ Cloud PKI Standards f√ºr Multi-Tenant-Umgebungen\n‚Ä¢ Zero Trust Architecture Standards mit PKI-Integration"
      },
      {
        _type: 'object',
        _key: generateKey('faq', 6),
        question: 'Wie wird PKI in Cloud-Umgebungen implementiert und welche besonderen Herausforderungen gibt es?',
        answer: "PKI-Implementierung in Cloud-Umgebungen erfordert spezielle Architekturen und Sicherheitsma√ünahmen, um den einzigartigen Herausforderungen von Skalierbarkeit, Multi-Tenancy, Compliance und Hybrid-Deployments gerecht zu werden. Cloud-PKI muss traditionelle Sicherheitsanforderungen mit Cloud-nativen Paradigmen vereinen.\n\n‚òÅÔ∏è Cloud-PKI-Architekturmodelle:\n‚Ä¢ Public Cloud PKI nutzt Cloud-Provider-Services f√ºr skalierbare PKI-Infrastruktur\n‚Ä¢ Private Cloud PKI implementiert dedizierte PKI-Systeme in isolierten Cloud-Umgebungen\n‚Ä¢ Hybrid Cloud PKI verbindet On-Premises-Root-CAs mit Cloud-basierten Issuing CAs\n‚Ä¢ Multi-Cloud PKI verteilt PKI-Komponenten √ºber mehrere Cloud-Provider f√ºr Redundanz\n‚Ä¢ Edge PKI erweitert Cloud-PKI auf Edge-Computing-Standorte f√ºr niedrige Latenz\n\nüîê Cloud-spezifische Sicherheitsherausforderungen:\n‚Ä¢ Shared Responsibility Model erfordert klare Abgrenzung zwischen Provider- und Kunden-Verantwortlichkeiten\n‚Ä¢ Data Residency und Sovereignty Anforderungen beeinflussen PKI-Deployment-Strategien\n‚Ä¢ Cloud Provider Access Controls m√ºssen mit PKI-Governance-Richtlinien harmonisiert werden\n‚Ä¢ Encryption Key Management in Multi-Tenant-Umgebungen erfordert strikte Isolation\n‚Ä¢ Network Security Groups und Virtual Private Clouds sch√ºtzen PKI-Kommunikation\n\nüèóÔ∏è Container und Kubernetes PKI:\n‚Ä¢ Container Image Signing gew√§hrleistet Integrit√§t von Container-Deployments\n‚Ä¢ Kubernetes Service Mesh PKI erm√∂glicht sichere Pod-zu-Pod-Kommunikation\n‚Ä¢ Secrets Management integriert PKI-Zertifikate in Kubernetes-native Workflows\n‚Ä¢ Admission Controllers validieren PKI-Compliance bei Container-Deployments\n‚Ä¢ Certificate Rotation Automation nutzt Kubernetes-Operatoren f√ºr Lifecycle-Management\n\nüîÑ DevOps und CI/CD Integration:\n‚Ä¢ Infrastructure as Code (IaC) Templates automatisieren PKI-Infrastruktur-Deployment\n‚Ä¢ GitOps Workflows integrieren PKI-Konfigurationsmanagement in Versionskontrolle\n‚Ä¢ Continuous Integration Pipelines nutzen PKI f√ºr Code-Signing und Artifact-Authentifizierung\n‚Ä¢ Automated Testing Frameworks validieren PKI-Funktionalit√§t in verschiedenen Umgebungen\n‚Ä¢ Blue-Green Deployments erm√∂glichen risikoarme PKI-Updates\n\nüìä Skalierbarkeit und Performance:\n‚Ä¢ Auto-Scaling PKI Services passen Kapazit√§t automatisch an Lastanforderungen an\n‚Ä¢ Load Balancing verteilt PKI-Anfragen optimal √ºber verf√ºgbare Instanzen\n‚Ä¢ Caching Strategies reduzieren Latenz bei h√§ufigen Zertifikatsvalidierungen\n‚Ä¢ Content Delivery Networks (CDN) beschleunigen CRL und OCSP-Verteilung\n‚Ä¢ Database Sharding skaliert PKI-Metadaten-Speicherung horizontal\n\nüõ°Ô∏è Compliance und Governance:\n‚Ä¢ Cloud Security Posture Management (CSPM) √ºberwacht PKI-Compliance kontinuierlich\n‚Ä¢ Audit Logging erfasst alle PKI-Operationen f√ºr Compliance-Nachweise\n‚Ä¢ Data Loss Prevention (DLP) sch√ºtzt PKI-Schl√ºsselmaterial vor unberechtigtem Zugriff\n‚Ä¢ Identity and Access Management (IAM) Integration steuert PKI-Administratorzugriff\n‚Ä¢ Regulatory Compliance Frameworks (SOC 2, ISO 27001) f√ºr Cloud-PKI-Betrieb\n\nüåê Hybrid und Multi-Cloud Connectivity:\n‚Ä¢ VPN und Private Connectivity verbinden Cloud-PKI mit On-Premises-Systemen sicher\n‚Ä¢ Cross-Cloud Certificate Validation erm√∂glicht Vertrauen zwischen verschiedenen Cloud-Providern\n‚Ä¢ Federated Identity Integration verbindet Cloud-PKI mit bestehenden Identity-Systemen\n‚Ä¢ API Gateway Security nutzt PKI f√ºr sichere Cloud-Service-Kommunikation\n‚Ä¢ Disaster Recovery Strategies replizieren PKI-Systeme √ºber Cloud-Regionen hinweg\n\nüîß Cloud-native PKI Services:\n‚Ä¢ Managed PKI Services reduzieren operative Komplexit√§t durch Provider-Management\n‚Ä¢ Serverless PKI Functions erm√∂glichen event-driven PKI-Operationen\n‚Ä¢ Microservices Architecture zerlegt PKI-Funktionalit√§t in unabh√§ngige Services\n‚Ä¢ API-first Design erm√∂glicht nahtlose Integration in Cloud-native Anwendungen\n‚Ä¢ Observability und Monitoring nutzen Cloud-native Tools f√ºr PKI-√úberwachung"
      },
      {
        _type: 'object',
        _key: generateKey('faq', 7),
        question: 'Welche Rolle spielt PKI bei Zero Trust Architectures und wie wird sie implementiert?',
        answer: "PKI bildet das kryptographische Fundament von Zero Trust Architectures, indem sie kontinuierliche Authentifizierung, Autorisierung und Verschl√ºsselung f√ºr alle Netzwerk-Interaktionen erm√∂glicht. In Zero Trust-Umgebungen wird PKI vom traditionellen Perimeter-Schutz zu einem allgegenw√§rtigen Vertrauens- und Identit√§tssystem transformiert.\n\nüõ°Ô∏è Zero Trust PKI Grundprinzipien:\n‚Ä¢ Never Trust, Always Verify erfordert kontinuierliche PKI-basierte Authentifizierung f√ºr alle Entit√§ten\n‚Ä¢ Least Privilege Access nutzt PKI-Zertifikate f√ºr granulare Autorisierungsentscheidungen\n‚Ä¢ Assume Breach Mindset implementiert PKI-Verschl√ºsselung f√ºr alle Daten√ºbertragungen\n‚Ä¢ Continuous Monitoring √ºberwacht PKI-Zertifikatsstatus und -nutzung in Echtzeit\n‚Ä¢ Context-Aware Security ber√ºcksichtigt PKI-Identit√§tsinformationen bei Zugriffsentscheidungen\n\nüîê Identity-Centric Security Model:\n‚Ä¢ Device Identity Certificates authentifizieren alle Endger√§te vor Netzwerkzugriff\n‚Ä¢ User Identity Certificates erm√∂glichen starke Benutzerauthentifizierung ohne Passw√∂rter\n‚Ä¢ Service Identity Certificates sichern Microservice-zu-Microservice-Kommunikation\n‚Ä¢ Workload Identity Management automatisiert PKI f√ºr Container und Cloud-Workloads\n‚Ä¢ Dynamic Identity Binding verkn√ºpft PKI-Identit√§ten mit Kontext und Verhalten\n\nüåê Micro-Segmentation und Encryption:\n‚Ä¢ Software-Defined Perimeters (SDP) nutzen PKI f√ºr sichere Netzwerk-Mikrosegmentierung\n‚Ä¢ Mutual TLS (mTLS) Authentication gew√§hrleistet bidirektionale PKI-Authentifizierung\n‚Ä¢ End-to-End Encryption sch√ºtzt Daten mit PKI-Schl√ºsseln √ºber gesamte Kommunikationspfade\n‚Ä¢ Application-Layer Security integriert PKI direkt in Anwendungslogik\n‚Ä¢ Network Function Virtualization (NFV) nutzt PKI f√ºr sichere virtuelle Netzwerkfunktionen\n\nüìä Policy Engine Integration:\n‚Ä¢ Attribute-Based Access Control (ABAC) nutzt PKI-Zertifikatsattribute f√ºr Autorisierungsentscheidungen\n‚Ä¢ Risk-Based Authentication bewertet PKI-Zertifikatsstatus bei Zugriffsentscheidungen\n‚Ä¢ Behavioral Analytics korrelieren PKI-Nutzungsmuster mit Sicherheitsrisiken\n‚Ä¢ Threat Intelligence Integration nutzt PKI-Daten f√ºr erweiterte Bedrohungserkennung\n‚Ä¢ Automated Response Systems reagieren auf PKI-Anomalien mit sofortigen Schutzma√ünahmen\n\nüîÑ Dynamic Trust Evaluation:\n‚Ä¢ Real-time Certificate Validation pr√ºft Zertifikatsstatus bei jeder Transaktion\n‚Ä¢ Trust Score Calculation bewertet Vertrauensw√ºrdigkeit basierend auf PKI-Metriken\n‚Ä¢ Adaptive Authentication passt Sicherheitsanforderungen an PKI-Vertrauenslevel an\n‚Ä¢ Continuous Risk Assessment nutzt PKI-Daten f√ºr dynamische Risikobewertung\n‚Ä¢ Contextual Policy Enforcement ber√ºcksichtigt PKI-Identit√§tskontext bei Richtliniendurchsetzung\n\nüèóÔ∏è Architecture Patterns f√ºr Zero Trust PKI:\n‚Ä¢ Service Mesh PKI implementiert Zero Trust f√ºr Microservices-Architekturen\n‚Ä¢ API Gateway PKI sichert alle API-Kommunikation mit Zero Trust-Prinzipien\n‚Ä¢ Cloud-Native PKI nutzt Container-Orchestrierung f√ºr skalierbare Zero Trust-Implementierung\n‚Ä¢ Edge Computing PKI erweitert Zero Trust auf verteilte Edge-Standorte\n‚Ä¢ IoT Zero Trust PKI skaliert Vertrauensmodelle f√ºr massive IoT-Deployments\n\nüõ†Ô∏è Implementation Strategies:\n‚Ä¢ Phased Rollout beginnt mit kritischen Assets und erweitert Zero Trust schrittweise\n‚Ä¢ Legacy Integration verbindet bestehende Systeme mit Zero Trust PKI-Frameworks\n‚Ä¢ Vendor-Agnostic Approaches vermeiden Lock-in durch standardbasierte PKI-Implementierung\n‚Ä¢ Performance Optimization minimiert Latenz durch intelligente PKI-Caching-Strategien\n‚Ä¢ Operational Excellence automatisiert PKI-Management f√ºr Zero Trust-Skalierung\n\nüìà Monitoring und Analytics:\n‚Ä¢ PKI Telemetry sammelt detaillierte Metriken √ºber Zero Trust-Authentifizierungen\n‚Ä¢ Security Information and Event Management (SIEM) Integration korreliert PKI-Events\n‚Ä¢ User and Entity Behavior Analytics (UEBA) nutzen PKI-Daten f√ºr Anomalieerkennung\n‚Ä¢ Compliance Reporting dokumentiert Zero Trust PKI-Aktivit√§ten f√ºr Audit-Zwecke\n‚Ä¢ Threat Hunting nutzt PKI-Logs f√ºr proaktive Sicherheitsuntersuchungen"
      },
      {
        _type: 'object',
        _key: generateKey('faq', 8),
        question: 'Wie werden PKI-Systeme f√ºr IoT und Industrial IoT (IIoT) Umgebungen angepasst?',
        answer: "PKI-Implementierung f√ºr IoT und Industrial IoT erfordert spezialisierte Ans√§tze, die den einzigartigen Herausforderungen von Ressourcenbeschr√§nkungen, Skalierbarkeit, Lifecycle-Management und operationaler Technologie gerecht werden. IoT-PKI muss Millionen von Ger√§ten sicher verwalten, w√§hrend sie gleichzeitig minimale Ressourcen verbraucht.\n\nüîß Resource-Constrained PKI Design:\n‚Ä¢ Lightweight Cryptography nutzt optimierte Algorithmen f√ºr begrenzte Rechenkapazit√§ten\n‚Ä¢ Elliptic Curve Cryptography (ECC) bietet starke Sicherheit bei geringerem Ressourcenverbrauch\n‚Ä¢ Certificate Compression reduziert Speicher- und Bandbreitenanforderungen\n‚Ä¢ Hierarchical Key Management minimiert On-Device-Schl√ºsselspeicherung\n‚Ä¢ Hardware Security Elements integrieren PKI-Funktionalit√§t in IoT-Chips\n\nüì° Scalable Certificate Provisioning:\n‚Ä¢ Manufacturing Integration baut PKI-Zertifikate direkt in Produktionsprozesse ein\n‚Ä¢ Bulk Certificate Generation erstellt Millionen von Zertifikaten effizient\n‚Ä¢ Device Identity Injection installiert eindeutige Identit√§ten w√§hrend der Fertigung\n‚Ä¢ Supply Chain Security gew√§hrleistet Integrit√§t von PKI-Komponenten durch gesamte Lieferkette\n‚Ä¢ Zero-Touch Provisioning erm√∂glicht automatische PKI-Konfiguration bei Erstverbindung\n\nüè≠ Industrial IoT Specific Requirements:\n‚Ä¢ Operational Technology (OT) Integration verbindet PKI mit industriellen Steuerungssystemen\n‚Ä¢ Real-Time Communication Security gew√§hrleistet PKI-Schutz ohne Latenz-Impact\n‚Ä¢ Safety-Critical Systems nutzen PKI f√ºr funktionale Sicherheit in kritischen Anwendungen\n‚Ä¢ Legacy Protocol Support erweitert PKI auf bestehende industrielle Kommunikationsprotokolle\n‚Ä¢ Harsh Environment Resilience implementiert PKI f√ºr extreme Betriebsbedingungen\n\nüîÑ Lifecycle Management at Scale:\n‚Ä¢ Automated Certificate Renewal bew√§ltigt Millionen von Zertifikatserneuerungen\n‚Ä¢ Remote Device Management erm√∂glicht PKI-Updates ohne physischen Zugriff\n‚Ä¢ Firmware Update Security nutzt PKI f√ºr sichere Over-the-Air-Updates\n‚Ä¢ Device Decommissioning revoziert Zertifikate bei Ger√§te-End-of-Life\n‚Ä¢ Certificate Inventory Tracking √ºberwacht PKI-Status √ºber gesamte IoT-Flotte\n\nüåê Edge Computing Integration:\n‚Ä¢ Edge PKI Services bringen Zertifikatsvalidierung n√§her zu IoT-Ger√§ten\n‚Ä¢ Distributed Trust Models reduzieren Abh√§ngigkeit von zentralen PKI-Systemen\n‚Ä¢ Offline Operation Capability erm√∂glicht PKI-Funktionalit√§t bei Netzwerkunterbrechungen\n‚Ä¢ Local Certificate Authorities an Edge-Standorten f√ºr reduzierte Latenz\n‚Ä¢ Fog Computing PKI nutzt Zwischenschichten f√ºr skalierbare PKI-Services\n\nüõ°Ô∏è Security f√ºr Constrained Environments:\n‚Ä¢ Mutual Authentication zwischen IoT-Ger√§ten und Backend-Systemen\n‚Ä¢ Secure Boot Processes nutzen PKI f√ºr vertrauensw√ºrdige Ger√§testarts\n‚Ä¢ Attestation Mechanisms beweisen Ger√§teintegrit√§t durch PKI-Signaturen\n‚Ä¢ Secure Communication Protocols (DTLS, CoAP) integrieren PKI f√ºr IoT-Kommunikation\n‚Ä¢ Anti-Tampering Measures sch√ºtzen PKI-Schl√ºssel in physisch zug√§nglichen Ger√§ten\n\nüìä Protocol-Specific Implementations:\n‚Ä¢ MQTT Security nutzt PKI f√ºr sichere IoT-Messaging\n‚Ä¢ CoAP (Constrained Application Protocol) PKI f√ºr Web-of-Things-Anwendungen\n‚Ä¢ LoRaWAN Security Integration f√ºr Low-Power Wide-Area Networks\n‚Ä¢ 5G Network Slicing PKI f√ºr dedizierte IoT-Netzwerksegmente\n‚Ä¢ Thread und Zigbee PKI f√ºr Mesh-Netzwerk-Sicherheit\n\nüèóÔ∏è Architecture Patterns:\n‚Ä¢ Hierarchical PKI Models mit speziellen IoT-Intermediate-CAs\n‚Ä¢ Federated IoT PKI f√ºr Multi-Vendor-Umgebungen\n‚Ä¢ Blockchain-Enhanced PKI f√ºr dezentrale IoT-Vertrauensmodelle\n‚Ä¢ Hybrid Cloud-Edge PKI f√ºr optimale Performance und Sicherheit\n‚Ä¢ Microservice-Based PKI f√ºr skalierbare IoT-Backend-Integration\n\n‚ö° Performance Optimization:\n‚Ä¢ Certificate Caching Strategies f√ºr h√§ufig validierte IoT-Identit√§ten\n‚Ä¢ Batch Processing f√ºr effiziente Massenoperationen\n‚Ä¢ Compression Algorithms f√ºr minimale Daten√ºbertragung\n‚Ä¢ Power-Aware PKI Operations f√ºr batteriebetriebene Ger√§te\n‚Ä¢ Network-Efficient Protocols f√ºr begrenzte Bandbreite"
      }
    ]
    
    // Update the document with new FAQs
    const updatedFaqs = [...(existingDoc.faq || []), ...newFaqs]
    
    console.log(`Adding ${newFaqs.length} new FAQs to the document...`)
    const transaction = client.transaction()
    transaction.patch(existingDoc._id, {
      set: {
        faq: updatedFaqs
      }
    })
    
    await transaction.commit()
    console.log('‚úÖ FAQ batch 2 added successfully')
  } catch (error) {
    console.error('Error:', error)
    throw error
  }
}

run()
