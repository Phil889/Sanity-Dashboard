import 'dotenv/config'
import { createClient } from '@sanity/client'

// Create client with direct credentials
const client = createClient({
  projectId: 'wwmm9rbb',
  dataset: 'production',
  apiVersion: '2024-02-14',
  token: process.env.SANITY_API_TOKEN,
  useCdn: false,
})

// Helper function to generate unique keys
function generateKey(prefix: string, index: number): string {
  return `${prefix}_${Date.now()}_${index}`
}

const run = async () => {
  try {
    console.log('Updating FIDA Sandbox and Testing page with FAQs batch 3...')
    
    // First, get the existing document
    console.log('Fetching existing document...')
    const existingDoc = await client.fetch('*[_id == $id][0]', { id: 'fida-sandbox-and-testing' })
    
    if (!existingDoc) {
      throw new Error('Document "fida-sandbox-and-testing" not found')
    }
    
    // Create new FAQs
    const newFaqs = [
      {
        _type: 'object',
        _key: generateKey('faq', 9),
        question: 'Wie implementiert ADVISORI Container-basierte Testing-Umgebungen und Cloud-native Testing-Strategien f√ºr skalierbare FIDA-Sandbox-Deployments?',
        answer: "Container-basierte Testing-Umgebungen revolutionieren die Art, wie FIDA-Sandbox-Umgebungen bereitgestellt und verwaltet werden. ADVISORI implementiert moderne Container-Orchestrierungs-Strategien, die Skalierbarkeit, Konsistenz und Effizienz in FIDA-Testing-Prozessen gew√§hrleisten und dabei Cloud-native Prinzipien optimal nutzen.\n\nüê≥ Advanced Container Orchestration:\n‚Ä¢ Kubernetes-Based Testing Infrastructure: Entwicklung von Kubernetes-basierten Testing-Clustern, die automatische Skalierung, Service-Discovery und Load-Balancing f√ºr FIDA-Testing-Workloads bereitstellen.\n‚Ä¢ Microservices Testing Architecture: Implementation von Container-basierten Microservices-Testing-Architekturen, die isolierte Testing verschiedener FIDA-Komponenten erm√∂glichen.\n‚Ä¢ Container Registry Management: Aufbau privater Container-Registries f√ºr FIDA-spezifische Testing-Images mit Versionskontrolle und Security-Scanning.\n‚Ä¢ Helm Chart Development: Erstellung wiederverwendbarer Helm Charts f√ºr standardisierte Deployment von FIDA-Testing-Umgebungen.\n‚Ä¢ Service Mesh Integration: Integration von Service Mesh-Technologien f√ºr erweiterte Observability und Traffic-Management in Testing-Umgebungen.\n\n‚òÅÔ∏è Cloud-Native Testing Strategies:\n‚Ä¢ Multi-Cloud Testing Deployment: Implementation von Multi-Cloud-Testing-Strategien, die Vendor-Lock-in vermeiden und geografische Verteilung erm√∂glichen.\n‚Ä¢ Serverless Testing Functions: Nutzung von Serverless-Computing f√ºr event-driven Testing-Szenarien und kosteneffiziente Test-Execution.\n‚Ä¢ Cloud-Native CI/CD Pipelines: Entwicklung vollst√§ndig cloud-nativer CI/CD-Pipelines mit automatischer Infrastruktur-Bereitstellung und -Verwaltung.\n‚Ä¢ Infrastructure as Code Integration: Implementation von Infrastructure as Code-Praktiken f√ºr reproduzierbare und versionskontrollierte Testing-Infrastrukturen.\n‚Ä¢ Auto-Scaling Testing Resources: Automatische Skalierung von Testing-Ressourcen basierend auf Workload-Anforderungen und Performance-Metriken.\n\nüîÑ Dynamic Environment Management:\n‚Ä¢ Ephemeral Testing Environments: Erstellung kurzlebiger Testing-Umgebungen, die automatisch f√ºr spezifische Tests bereitgestellt und nach Abschluss zerst√∂rt werden.\n‚Ä¢ Environment Templating: Entwicklung von Environment-Templates, die schnelle Bereitstellung konsistenter Testing-Umgebungen f√ºr verschiedene FIDA-Szenarien erm√∂glichen.\n‚Ä¢ Resource Optimization: Intelligente Ressourcenoptimierung durch Container-Scheduling und Resource-Quotas zur Kostenminimierung.\n‚Ä¢ Blue-Green Testing Deployments: Implementation von Blue-Green-Deployment-Strategien f√ºr risikofreie Testing-Environment-Updates.\n‚Ä¢ Canary Testing Releases: Nutzung von Canary-Release-Strategien f√ºr graduelle Einf√ºhrung neuer Testing-Features und -Konfigurationen.\n\nüõ°Ô∏è Security und Compliance in Container Environments:\n‚Ä¢ Container Security Scanning: Automatisches Security-Scanning von Container-Images auf Vulnerabilities und Compliance-Verletzungen.\n‚Ä¢ Runtime Security Monitoring: Kontinuierliche √úberwachung von Container-Runtime-Sicherheit mit Anomalie-Erkennung und Threat-Detection.\n‚Ä¢ Network Segmentation: Implementation von Netzwerk-Segmentierung und Micro-Segmentation f√ºr isolierte Testing-Workloads.\n‚Ä¢ Secrets Management: Sichere Verwaltung von Secrets und Credentials in Container-Umgebungen mit automatischer Rotation.\n‚Ä¢ Compliance-as-Code: Integration von Compliance-Checks in Container-Deployment-Pipelines mit automatischer Policy-Enforcement.\n\nüìä Observability und Monitoring:\n‚Ä¢ Distributed Tracing: Implementation von Distributed-Tracing-Systemen f√ºr End-to-End-Visibilit√§t in containerisierten Testing-Umgebungen.\n‚Ä¢ Metrics Collection und Visualization: Umfassende Metriken-Sammlung mit benutzerdefinierten Dashboards f√ºr Container-Performance und Testing-KPIs.\n‚Ä¢ Log Aggregation und Analysis: Zentralisierte Log-Aggregation mit intelligenter Analyse und Alerting f√ºr Container-basierte Testing-Workloads.\n‚Ä¢ Health Checks und Probes: Implementation robuster Health-Check-Mechanismen f√ºr automatische Erkennung und Recovery von fehlerhaften Containern.\n‚Ä¢ Cost Monitoring und Optimization: Kontinuierliche √úberwachung von Cloud-Kosten mit Empfehlungen f√ºr Ressourcenoptimierung."
      },
      {
        _type: 'object',
        _key: generateKey('faq', 10),
        question: 'Welche Strategien nutzt ADVISORI f√ºr Chaos Engineering und Resilience Testing in FIDA-Sandbox-Umgebungen zur Validierung der Systemrobustheit?',
        answer: "Chaos Engineering f√ºr FIDA-Systeme erfordert spezialisierte Ans√§tze, die die kritische Natur von Financial Services ber√ºcksichtigen. ADVISORI implementiert kontrollierte Chaos-Engineering-Strategien, die Systemresilienz validieren, ohne Produktionsumgebungen zu gef√§hrden, und dabei regulatorische Anforderungen an Systemstabilit√§t erf√ºllen.\n\nüå™Ô∏è Controlled Chaos Engineering Framework:\n‚Ä¢ Hypothesis-Driven Chaos Experiments: Entwicklung wissenschaftlich fundierter Chaos-Experimente basierend auf spezifischen Hypothesen √ºber Systemverhalten und Ausfallszenarien.\n‚Ä¢ Blast Radius Control: Implementation strenger Blast-Radius-Kontrollen, die sicherstellen, dass Chaos-Experimente auf definierte Bereiche beschr√§nkt bleiben.\n‚Ä¢ Gradual Chaos Introduction: Systematische Einf√ºhrung von Chaos-Experimenten mit gradueller Steigerung der Komplexit√§t und Auswirkungen.\n‚Ä¢ Automated Rollback Mechanisms: Entwicklung automatischer Rollback-Mechanismen, die Experimente sofort stoppen, wenn unerwartete Auswirkungen auftreten.\n‚Ä¢ Chaos Experiment Scheduling: Intelligente Planung von Chaos-Experimenten basierend auf Systemlast, Gesch√§ftszyklen und Wartungsfenstern.\n\nüîß Infrastructure Chaos Testing:\n‚Ä¢ Network Partition Simulation: Simulation von Netzwerk-Partitionen und Latenz-Problemen zur Validierung der Systemresilienz gegen Netzwerk-Ausf√§lle.\n‚Ä¢ Resource Exhaustion Testing: Kontrollierte Ersch√∂pfung von System-Ressourcen wie CPU, Memory und Disk-Space zur Validierung von Resource-Management-Strategien.\n‚Ä¢ Service Dependency Failures: Simulation von Ausf√§llen kritischer Service-Dependencies zur Validierung von Circuit-Breaker-Patterns und Fallback-Mechanismen.\n‚Ä¢ Database Failure Scenarios: Testing von Datenbankausf√§llen, Replikations-Problemen und Konsistenz-Issues in verteilten Datenbank-Umgebungen.\n‚Ä¢ Cloud Provider Outage Simulation: Simulation von Cloud-Provider-Ausf√§llen zur Validierung von Multi-Cloud und Disaster-Recovery-Strategien.\n\nüèóÔ∏è Application-Level Chaos Engineering:\n‚Ä¢ API Failure Injection: Gezielte Injektion von API-Fehlern zur Validierung von Error-Handling und Retry-Mechanismen in FIDA-Implementierungen.\n‚Ä¢ Microservices Chaos Testing: Spezialisierte Chaos-Tests f√ºr Microservices-Architekturen, einschlie√ülich Service-Mesh-Failures und Inter-Service-Communication-Problems.\n‚Ä¢ Data Corruption Scenarios: Kontrollierte Simulation von Datenkorruption zur Validierung von Data-Integrity-Checks und Recovery-Prozessen.\n‚Ä¢ Authentication und Authorization Failures: Testing von Authentication- und Authorization-System-Ausf√§llen zur Validierung von Security-Fallback-Mechanismen.\n‚Ä¢ Message Queue Chaos: Simulation von Message-Queue-Problemen zur Validierung von Asynchronous-Processing-Resilienz.\n\nüìà Resilience Metrics und Measurement:\n‚Ä¢ Mean Time to Recovery Measurement: Systematische Messung von MTTR f√ºr verschiedene Ausfallszenarien zur Identifikation von Verbesserungsm√∂glichkeiten.\n‚Ä¢ System Degradation Analysis: Analyse des System-Degradation-Verhaltens unter verschiedenen Stress-Bedingungen.\n‚Ä¢ Cascade Failure Detection: Identifikation und Analyse von Cascade-Failure-Patterns zur Verbesserung von System-Isolation.\n‚Ä¢ Business Impact Assessment: Bewertung der Gesch√§ftsauswirkungen verschiedener Ausfallszenarien zur Priorisierung von Resilience-Verbesserungen.\n‚Ä¢ Recovery Time Optimization: Kontinuierliche Optimierung von Recovery-Zeiten durch iterative Chaos-Experimente.\n\nüéØ Scenario-Based Chaos Testing:\n‚Ä¢ Regulatory Deadline Stress Testing: Simulation von Hochlast-Szenarien w√§hrend regulatorischer Deadline-Perioden zur Validierung der Systemstabilit√§t.\n‚Ä¢ Peak Trading Hours Simulation: Chaos-Testing w√§hrend simulierter Peak-Trading-Zeiten zur Validierung der Performance unter Stress.\n‚Ä¢ Multi-Jurisdictional Failure Scenarios: Testing von Ausfallszenarien, die mehrere regulatorische Jurisdiktionen betreffen.\n‚Ä¢ Third-Party Integration Failures: Simulation von Drittanbieter-Service-Ausf√§llen zur Validierung von Integration-Resilienz.\n‚Ä¢ Compliance System Chaos: Spezialisierte Chaos-Tests f√ºr Compliance-kritische Systeme mit Fokus auf Audit-Trail-Integrit√§t."
      },
      {
        _type: 'object',
        _key: generateKey('faq', 11),
        question: 'Wie entwickelt ADVISORI API-Mocking und Service-Virtualization-Strategien f√ºr FIDA-Testing, um externe Dependencies zu simulieren und isolierte Tests zu erm√∂glichen?',
        answer: "API-Mocking und Service-Virtualization f√ºr FIDA-Testing erfordern hochentwickelte Strategien, die komplexe Financial Services Ecosystems akkurat simulieren. ADVISORI entwickelt umfassende Virtualization-Frameworks, die realistische Testing-Szenarien erm√∂glichen, w√§hrend sie gleichzeitig Kosten reduzieren und Testing-Geschwindigkeit erh√∂hen.\n\nüé≠ Advanced Service Virtualization Framework:\n‚Ä¢ Behavioral Service Modeling: Entwicklung verhaltensbasierter Service-Modelle, die nicht nur API-Responses simulieren, sondern auch komplexe Gesch√§ftslogik und State-Management nachbilden.\n‚Ä¢ Dynamic Response Generation: Implementation dynamischer Response-Generierung basierend auf Request-Parametern, historischen Daten und Gesch√§ftsregeln.\n‚Ä¢ Stateful Service Simulation: Erstellung zustandsbehafteter Service-Simulationen, die Session-Management und transaktionale Konsistenz nachbilden.\n‚Ä¢ Performance Characteristic Modeling: Simulation realistischer Performance-Charakteristika externer Services, einschlie√ülich Latenz-Variationen und Durchsatz-Limits.\n‚Ä¢ Error Scenario Simulation: Umfassende Simulation verschiedener Error-Szenarien, einschlie√ülich Timeout, Rate-Limiting und Service-Unavailability.\n\nüîÑ Intelligent Mock Management:\n‚Ä¢ Contract-Based Mock Generation: Automatische Generierung von Mocks basierend auf API-Contracts und OpenAPI-Spezifikationen.\n‚Ä¢ Data-Driven Mock Responses: Nutzung realer Datenpatterns f√ºr die Generierung realistischer Mock-Responses ohne Verwendung echter Produktionsdaten.\n‚Ä¢ Conditional Mock Behavior: Implementation konditionaler Mock-Logik, die verschiedene Responses basierend auf Request-Kontext und Testing-Szenarien liefert.\n‚Ä¢ Mock Versioning und Lifecycle Management: Versionskontrolle f√ºr Mock-Services mit automatischem Lifecycle-Management und Backward-Compatibility.\n‚Ä¢ A/B Testing f√ºr Mocks: M√∂glichkeit, verschiedene Mock-Versionen parallel zu testen, um optimale Service-Simulation zu identifizieren.\n\nüè¶ Financial Services Specific Virtualization:\n‚Ä¢ Core Banking System Simulation: Detaillierte Simulation von Core-Banking-Systemen mit realistischen Account-Management und Transaction-Processing-Capabilities.\n‚Ä¢ Payment Gateway Virtualization: Umfassende Virtualization von Payment-Gateways mit verschiedenen Payment-Methods und Compliance-Szenarien.\n‚Ä¢ Credit Bureau API Simulation: Simulation von Credit-Bureau-APIs mit realistischen Credit-Scoring und Risk-Assessment-Responses.\n‚Ä¢ Regulatory Reporting System Mocks: Spezialisierte Mocks f√ºr regulatorische Reporting-Systeme mit korrekten Datenformaten und Validierungsregeln.\n‚Ä¢ Market Data Feed Simulation: Real-time Market-Data-Feed-Simulation f√ºr Trading und Investment-Related FIDA-Testing.\n\nüõ†Ô∏è Advanced Testing Scenario Support:\n‚Ä¢ Multi-Tenant Mock Environments: Erstellung von Multi-Tenant-Mock-Umgebungen, die verschiedene Kunden- oder Jurisdiktions-spezifische Szenarien simulieren.\n‚Ä¢ Chaos Monkey f√ºr Mocks: Integration von Chaos-Engineering-Prinzipien in Mock-Services zur Simulation unvorhersehbarer Service-Verhaltensweisen.\n‚Ä¢ Load Testing Mock Scalability: Skalierbare Mock-Services, die hohe Lasten f√ºr Performance-Testing unterst√ºtzen k√∂nnen.\n‚Ä¢ Time-Based Scenario Simulation: Simulation zeitbasierter Szenarien, einschlie√ülich Gesch√§ftszeiten, Feiertage und regulatorische Deadline-Perioden.\n‚Ä¢ Geographic Distribution Mocking: Simulation geografisch verteilter Services mit regionsspezifischen Responses und Compliance-Anforderungen.\n\nüìä Mock Analytics und Optimization:\n‚Ä¢ Mock Usage Analytics: Detaillierte Analyse der Mock-Nutzung zur Identifikation von Optimierungsm√∂glichkeiten und ungenutzten Szenarien.\n‚Ä¢ Response Time Optimization: Kontinuierliche Optimierung von Mock-Response-Zeiten zur Verbesserung der Testing-Effizienz.\n‚Ä¢ Mock Accuracy Validation: Regelm√§√üige Validierung der Mock-Genauigkeit durch Vergleich mit echten Service-Responses.\n‚Ä¢ Test Coverage Analysis: Analyse der Test-Coverage durch verschiedene Mock-Szenarien zur Identifikation von Testing-Gaps.\n‚Ä¢ Mock Maintenance Automation: Automatisierte Wartung und Updates von Mock-Services basierend auf API-√Ñnderungen und neuen Requirements.\n\nüîí Security und Compliance in Virtualization:\n‚Ä¢ Secure Mock Data Generation: Generierung sicherer Mock-Daten, die keine echten Kundendaten enthalten, aber realistische Patterns beibehalten.\n‚Ä¢ Compliance-Aware Mocking: Integration von Compliance-Anforderungen in Mock-Services zur Validierung regulatorischer Szenarien.\n‚Ä¢ Access Control f√ºr Mock Services: Implementation granularer Zugriffskontrolle f√ºr Mock-Services basierend auf Benutzerrollen und Testing-Szenarien.\n‚Ä¢ Audit Trail f√ºr Mock Interactions: Umfassende Protokollierung aller Mock-Interaktionen f√ºr Compliance und Debugging-Zwecke.\n‚Ä¢ Data Privacy in Virtualization: Sicherstellung, dass virtualisierte Services Datenschutzanforderungen erf√ºllen und keine sensiblen Daten preisgeben."
      },
      {
        _type: 'object',
        _key: generateKey('faq', 12),
        question: 'Welche Methoden implementiert ADVISORI f√ºr Cross-Browser und Cross-Platform Testing von FIDA-Interfaces, um konsistente Benutzererfahrungen sicherzustellen?',
        answer: "Cross-Browser und Cross-Platform Testing f√ºr FIDA-Interfaces erfordert umfassende Strategien, die die Vielfalt moderner Ger√§te und Browser ber√ºcksichtigen. ADVISORI implementiert automatisierte Testing-Frameworks, die konsistente Benutzererfahrungen √ºber alle Plattformen hinweg gew√§hrleisten und dabei Accessibility und Performance-Standards erf√ºllen.\n\nüåê Comprehensive Browser Testing Matrix:\n‚Ä¢ Multi-Browser Automation Framework: Entwicklung automatisierter Testing-Frameworks, die alle g√§ngigen Browser (Chrome, Firefox, Safari, Edge) und deren verschiedene Versionen abdecken.\n‚Ä¢ Legacy Browser Support Testing: Spezialisierte Tests f√ºr Legacy-Browser, die in Enterprise-Umgebungen noch verwendet werden, mit Graceful-Degradation-Strategien.\n‚Ä¢ Browser-Specific Feature Testing: Gezielte Tests f√ºr browser-spezifische Features und APIs, die in FIDA-Implementierungen verwendet werden.\n‚Ä¢ Progressive Web App Testing: Umfassende Tests f√ºr PWA-Features wie Service Workers, Offline-Funktionalit√§t und App-Installation.\n‚Ä¢ Browser Security Model Testing: Validierung der Funktionalit√§t unter verschiedenen Browser-Sicherheitsmodellen und Content-Security-Policies.\n\nüì± Mobile und Responsive Testing Strategies:\n‚Ä¢ Device Farm Integration: Integration mit Cloud-basierten Device-Farms f√ºr Testing auf echten Ger√§ten verschiedener Hersteller und Betriebssystemversionen.\n‚Ä¢ Responsive Design Validation: Automatisierte Tests f√ºr Responsive-Design-Breakpoints und Layout-Konsistenz √ºber verschiedene Bildschirmgr√∂√üen.\n‚Ä¢ Touch Interface Testing: Spezialisierte Tests f√ºr Touch-Interfaces, einschlie√ülich Gesture-Recognition und Multi-Touch-Funktionalit√§t.\n‚Ä¢ Mobile Performance Testing: Performance-Tests spezifisch f√ºr mobile Ger√§te, einschlie√ülich Battery-Usage und Network-Efficiency.\n‚Ä¢ Mobile Security Testing: Sicherheitstests f√ºr mobile FIDA-Implementierungen, einschlie√ülich App-Transport-Security und Certificate-Pinning.\n\nüñ•Ô∏è Desktop Platform Testing:\n‚Ä¢ Operating System Compatibility: Umfassende Tests auf verschiedenen Betriebssystemen (Windows, macOS, Linux) mit verschiedenen Versionen.\n‚Ä¢ Native App Testing: Testing von nativen Desktop-Anwendungen f√ºr FIDA-Zugang mit plattformspezifischen Features.\n‚Ä¢ Screen Resolution Testing: Tests f√ºr verschiedene Bildschirmaufl√∂sungen und DPI-Settings zur Sicherstellung optimaler Darstellung.\n‚Ä¢ Accessibility Testing: Umfassende Accessibility-Tests mit Screen-Readern und anderen Assistive-Technologies auf verschiedenen Plattformen.\n‚Ä¢ Keyboard Navigation Testing: Detaillierte Tests der Keyboard-Navigation f√ºr Accessibility und Power-User-Workflows.\n\nüîÑ Automated Cross-Platform Testing Pipeline:\n‚Ä¢ Parallel Test Execution: Parallelisierung von Cross-Platform-Tests zur Reduzierung der Testing-Zeit bei maximaler Coverage.\n‚Ä¢ Visual Regression Testing: Automatisierte Visual-Regression-Tests zur Identifikation von Layout- und Design-Inkonsistenzen zwischen Plattformen.\n‚Ä¢ Functional Consistency Validation: Systematische Validierung, dass alle Funktionen auf allen unterst√ºtzten Plattformen identisch funktionieren.\n‚Ä¢ Performance Baseline Comparison: Vergleich von Performance-Baselines zwischen verschiedenen Plattformen zur Identifikation von Optimierungsm√∂glichkeiten.\n‚Ä¢ User Journey Cross-Platform Testing: End-to-End-Tests kompletter User-Journeys auf verschiedenen Plattformen zur Sicherstellung konsistenter Erfahrungen.\n\nüéØ Specialized FIDA Interface Testing:\n‚Ä¢ Financial Data Visualization Testing: Spezialisierte Tests f√ºr komplexe Datenvisualisierungen und Charts, die in FIDA-Interfaces verwendet werden.\n‚Ä¢ Multi-Language Support Testing: Tests f√ºr Internationalisierung und Lokalisierung von FIDA-Interfaces in verschiedenen Sprachen und Regionen.\n‚Ä¢ Real-Time Data Update Testing: Validierung von Real-Time-Daten-Updates in FIDA-Interfaces √ºber verschiedene Plattformen und Netzwerkbedingungen.\n‚Ä¢ Complex Form Validation Testing: Umfassende Tests komplexer Formulare mit verschiedenen Validierungsregeln und Error-Handling-Szenarien.\n‚Ä¢ Print und Export Functionality Testing: Tests f√ºr Print- und Export-Funktionalit√§ten, die in Financial Services h√§ufig ben√∂tigt werden.\n\nüìä Testing Analytics und Optimization:\n‚Ä¢ Cross-Platform Performance Analytics: Detaillierte Analyse der Performance-Unterschiede zwischen Plattformen mit Optimierungsempfehlungen.\n‚Ä¢ User Behavior Analysis: Analyse von Benutzerverhalten auf verschiedenen Plattformen zur Identifikation plattformspezifischer UX-Verbesserungen.\n‚Ä¢ Error Pattern Analysis: Systematische Analyse von Error-Patterns auf verschiedenen Plattformen zur Priorisierung von Bug-Fixes.\n‚Ä¢ Feature Usage Statistics: Tracking der Feature-Nutzung auf verschiedenen Plattformen zur Informierung von Entwicklungspriorit√§ten.\n‚Ä¢ Accessibility Compliance Reporting: Automatisierte Generierung von Accessibility-Compliance-Reports f√ºr verschiedene Standards (WCAG, Section 508)."
      }
    ]
    
    // Update the document with new FAQs
    const updatedFaqs = [...(existingDoc.faq || []), ...newFaqs]
    
    console.log(`Adding ${newFaqs.length} new FAQs to the document...`)
    const transaction = client.transaction()
    transaction.patch(existingDoc._id, {
      set: {
        faq: updatedFaqs
      }
    })
    
    await transaction.commit()
    console.log('‚úÖ FAQs batch 3 added successfully')
  } catch (error) {
    console.error('Error:', error)
    throw error
  }
}

run()
