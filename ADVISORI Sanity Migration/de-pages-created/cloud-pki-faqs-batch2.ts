import 'dotenv/config'
import { createClient } from '@sanity/client'

// Create client with direct credentials
const client = createClient({
  projectId: 'wwmm9rbb',
  dataset: 'production',
  apiVersion: '2024-02-14',
  token: process.env.SANITY_API_TOKEN,
  useCdn: false,
})

// Helper function to generate unique keys
function generateKey(prefix: string, index: number): string {
  return `${prefix}_${Date.now()}_${index}`
}

const run = async () => {
  try {
    console.log('Updating Cloud PKI page with FAQ batch 2...')
    
    // First, get the existing document
    console.log('Fetching existing document...')
    const existingDoc = await client.fetch('*[_id == $id][0]', { id: 'cloud-pki' })
    
    if (!existingDoc) {
      throw new Error('Document "cloud-pki" not found')
    }
    
    // Create new FAQs for DevOps integration and container PKI
    const newFaqs = [
      {
        _type: 'object',
        _key: generateKey('faq', 5),
        question: 'Wie integriert sich Cloud PKI in DevOps-Workflows und CI/CD-Pipelines f√ºr automatisierte Certificate Management?',
        answer: "Cloud PKI transformiert traditionelle Certificate Management Prozesse durch nahtlose Integration in moderne DevOps-Workflows und CI/CD-Pipelines. Diese Integration erm√∂glicht es Entwicklungsteams, Sicherheit als integralen Bestandteil des Entwicklungsprozesses zu behandeln, anstatt sie als nachgelagerten Schritt zu betrachten.\n\nüîÑ GitOps-basierte PKI-Konfiguration:\n‚Ä¢ Infrastructure as Code Prinzipien f√ºr PKI-Konfigurationen mit Git als Single Source of Truth\n‚Ä¢ Versionierte PKI-Policies und Certificate Templates in Git-Repositories f√ºr vollst√§ndige Nachverfolgbarkeit\n‚Ä¢ Pull Request basierte √Ñnderungsprozesse f√ºr PKI-Konfigurationen mit Code Review und Approval Workflows\n‚Ä¢ Automated Testing von PKI-Konfigurationen vor Deployment in Produktionsumgebungen\n‚Ä¢ Rollback-F√§higkeiten f√ºr PKI-√Ñnderungen durch Git-basierte Versionskontrolle\n\nüöÄ CI/CD Pipeline Integration:\n‚Ä¢ Native Integration in Jenkins, GitLab CI, GitHub Actions und Azure DevOps f√ºr automatisierte Certificate Provisioning\n‚Ä¢ Pipeline Stages f√ºr Certificate Request, Validation, Issuance und Deployment ohne manuelle Intervention\n‚Ä¢ Automated Certificate Renewal als Teil der Deployment Pipeline mit Zero-Downtime Updates\n‚Ä¢ Integration Testing f√ºr Certificate-abh√§ngige Services in Staging-Umgebungen\n‚Ä¢ Automated Rollback bei Certificate-bezogenen Deployment-Fehlern\n\nüîß Developer Experience und Self-Service:\n‚Ä¢ CLI Tools und SDKs f√ºr Entwickler zur direkten Integration von PKI-Operationen in lokale Entwicklungsumgebungen\n‚Ä¢ Self-Service Certificate Portals mit Role-based Access Control f√ºr verschiedene Entwicklungsteams\n‚Ä¢ IDE Plugins f√ºr Visual Studio Code, IntelliJ und andere Entwicklungsumgebungen\n‚Ä¢ Local Development Certificate Provisioning f√ºr HTTPS-f√§hige lokale Entwicklungsserver\n‚Ä¢ Automated Certificate Injection in Container Images w√§hrend des Build-Prozesses\n\nüê≥ Container und Kubernetes Integration:\n‚Ä¢ cert-manager Integration f√ºr automatische Certificate Lifecycle Management in Kubernetes Clustern\n‚Ä¢ Helm Charts f√ºr standardisierte PKI-Deployments mit konfigurierbaren Certificate Policies\n‚Ä¢ Kubernetes Operators f√ºr erweiterte PKI-Funktionalit√§ten und Custom Resource Definitions\n‚Ä¢ Sidecar Container Patterns f√ºr Certificate Rotation ohne Application Downtime\n‚Ä¢ Service Mesh Integration f√ºr automatische mTLS zwischen Microservices\n\nüìä Monitoring und Observability:\n‚Ä¢ Integration in Prometheus und Grafana f√ºr PKI-Metriken und Certificate Expiry Monitoring\n‚Ä¢ Distributed Tracing f√ºr Certificate-bezogene Operations in komplexen Microservice-Architekturen\n‚Ä¢ Automated Alerting bei Certificate Expiry, Validation Failures oder PKI-Service Degradation\n‚Ä¢ Custom Dashboards f√ºr Development Teams mit Certificate Status und Usage Metrics\n‚Ä¢ Integration in ELK Stack f√ºr centralized Logging von PKI-Operations\n\nüîê Security und Compliance in DevOps:\n‚Ä¢ Automated Security Scanning von Certificate Configurations und Dependencies\n‚Ä¢ Policy as Code f√ºr PKI-Governance mit automated Compliance Checking\n‚Ä¢ Secrets Management Integration f√ºr sichere Speicherung von Private Keys und CA Materials\n‚Ä¢ Audit Trail Integration f√ºr alle Certificate-bezogenen Operations in DevOps Pipelines\n‚Ä¢ Vulnerability Scanning f√ºr PKI-Komponenten als Teil der Security Pipeline"
      },
      {
        _type: 'object',
        _key: generateKey('faq', 6),
        question: 'Welche spezifischen Vorteile bietet Cloud PKI f√ºr Container-Umgebungen und Kubernetes-Cluster?',
        answer: "Cloud PKI bietet spezialisierte L√∂sungen f√ºr die einzigartigen Herausforderungen von Container-Umgebungen und Kubernetes-Clustern, wo traditionelle PKI-Ans√§tze oft unzureichend sind. Die Cloud-native Architektur erm√∂glicht es, PKI-Services nahtlos in die dynamische und ephemere Natur von Container-Workloads zu integrieren.\n\nüéØ Kubernetes-native PKI-Integration:\n‚Ä¢ cert-manager als Kubernetes Operator f√ºr automatische Certificate Lifecycle Management ohne externe Dependencies\n‚Ä¢ Custom Resource Definitions f√ºr Certificate Requests, Issuers und ClusterIssuers mit deklarativer Konfiguration\n‚Ä¢ Automatic Certificate Provisioning f√ºr Ingress Controllers, Services und Pods basierend auf Annotations\n‚Ä¢ Integration mit Kubernetes RBAC f√ºr granulare Berechtigungskontrolle bei Certificate Operations\n‚Ä¢ Native Support f√ºr Kubernetes Secrets f√ºr sichere Certificate und Key Storage\n\nüîÑ Dynamic Certificate Management:\n‚Ä¢ Ephemeral Certificate Provisioning f√ºr kurzlebige Container mit automatischer Cleanup\n‚Ä¢ Just-in-Time Certificate Issuance basierend auf Pod Lifecycle Events\n‚Ä¢ Automatic Certificate Rotation ohne Pod Restarts durch Volume Mounts und Sidecar Patterns\n‚Ä¢ Horizontal Pod Autoscaler Integration f√ºr skalierbare Certificate Services\n‚Ä¢ Multi-Cluster Certificate Management f√ºr Kubernetes Federation und Multi-Cloud Deployments\n\nüåê Service Mesh PKI-Integration:\n‚Ä¢ Istio Service Mesh Integration f√ºr automatische mTLS zwischen allen Microservices\n‚Ä¢ Linkerd Integration mit automatischer Certificate Rotation und Trust Domain Management\n‚Ä¢ Consul Connect Integration f√ºr Service-to-Service Authentication und Authorization\n‚Ä¢ Envoy Proxy Integration f√ºr TLS Termination und Certificate Management\n‚Ä¢ SPIFFE/SPIRE Integration f√ºr Workload Identity und Attestation\n\nüîê Container Image Security:\n‚Ä¢ Container Image Signing mit Notary und Docker Content Trust f√ºr Supply Chain Security\n‚Ä¢ Cosign Integration f√ºr Kubernetes-native Container Signature Verification\n‚Ä¢ OCI Artifact Signing f√ºr Helm Charts, Policies und andere Kubernetes Artifacts\n‚Ä¢ Admission Controller Integration f√ºr automatische Signature Verification bei Pod Creation\n‚Ä¢ Registry Integration f√ºr automatische Image Scanning und Certificate Validation\n\n‚ö° Performance und Skalierung:\n‚Ä¢ In-Memory Certificate Caching f√ºr hochperformante Certificate Lookups in Container-Umgebungen\n‚Ä¢ Certificate Pre-provisioning f√ºr predictable Workload Patterns und Batch Jobs\n‚Ä¢ Distributed Certificate Stores f√ºr Multi-Region Kubernetes Clusters\n‚Ä¢ Edge Certificate Caching f√ºr geografisch verteilte Container Workloads\n‚Ä¢ Optimized Certificate Formats f√ºr minimale Container Image Sizes\n\nüõ†Ô∏è DevOps und Automation:\n‚Ä¢ Helm Chart Templates f√ºr standardisierte PKI-Deployments √ºber verschiedene Umgebungen\n‚Ä¢ Kustomize Integration f√ºr Environment-spezifische PKI-Konfigurationen\n‚Ä¢ ArgoCD und Flux Integration f√ºr GitOps-basierte PKI-Deployments\n‚Ä¢ Tekton Pipeline Integration f√ºr Cloud-native CI/CD mit automatischem Certificate Management\n‚Ä¢ Operator Framework f√ºr Custom PKI-Operators und Domain-spezifische Certificate Management\n\nüìä Observability und Debugging:\n‚Ä¢ Kubernetes Events Integration f√ºr Certificate-bezogene Ereignisse und Troubleshooting\n‚Ä¢ Prometheus Metrics f√ºr Certificate Expiry, Renewal Success Rates und Performance Metriken\n‚Ä¢ Jaeger Tracing Integration f√ºr End-to-End Visibility in Certificate-bezogenen Operations\n‚Ä¢ kubectl Plugins f√ºr einfache Certificate Management Operations direkt aus der Kommandozeile\n‚Ä¢ Grafana Dashboards f√ºr Container-spezifische PKI-Metriken und Alerting"
      },
      {
        _type: 'object',
        _key: generateKey('faq', 7),
        question: 'Wie funktioniert Hybrid Cloud PKI und welche Strategien gibt es f√ºr die Migration von On-Premises zu Cloud PKI?',
        answer: "Hybrid Cloud PKI erm√∂glicht es Unternehmen, die Vorteile von Cloud-Technologien zu nutzen, w√§hrend sie gleichzeitig bestehende On-Premises Infrastrukturen und Compliance-Anforderungen ber√ºcksichtigen. Diese Strategie ist besonders wichtig f√ºr Organisationen, die eine schrittweise Cloud-Transformation durchf√ºhren m√∂chten.\n\nüåâ Hybrid PKI-Architektur-Patterns:\n‚Ä¢ Bridge CA Modelle f√ºr sichere Verbindung zwischen On-Premises und Cloud PKI-Hierarchien\n‚Ä¢ Cross-Certification zwischen verschiedenen Certificate Authorities f√ºr nahtlose Trust Relationships\n‚Ä¢ Federated PKI-Modelle mit einheitlicher Policy-Governance √ºber Hybrid-Infrastrukturen\n‚Ä¢ Split-Brain Architekturen f√ºr geografische oder compliance-basierte Datenresidenz\n‚Ä¢ Disaster Recovery Strategien mit Cloud-basiertem Backup f√ºr On-Premises PKI-Komponenten\n\nüìã Migration-Strategien und Phasen:\n‚Ä¢ Assessment Phase mit detaillierter Analyse bestehender PKI-Infrastrukturen und Dependencies\n‚Ä¢ Pilot Phase mit ausgew√§hlten Non-Critical Workloads f√ºr Proof of Concept und Learning\n‚Ä¢ Parallel Operation Phase mit gleichzeitigem Betrieb von On-Premises und Cloud PKI\n‚Ä¢ Gradual Migration Phase mit schrittweiser Verlagerung von Workloads und Services\n‚Ä¢ Optimization Phase mit Konsolidierung und Performance-Tuning der Cloud PKI-Services\n\nüîÑ Datenintegration und Synchronisation:\n‚Ä¢ Real-time Certificate Store Synchronisation zwischen On-Premises und Cloud-Umgebungen\n‚Ä¢ Automated Certificate Lifecycle Synchronisation f√ºr konsistente Policy Enforcement\n‚Ä¢ CRL und OCSP Distribution √ºber Hybrid-Infrastrukturen f√ºr einheitliche Revocation Services\n‚Ä¢ Audit Log Aggregation aus verschiedenen PKI-Umgebungen f√ºr zentrale Compliance-Berichte\n‚Ä¢ Backup und Recovery Strategien f√ºr Hybrid PKI-Daten mit Cross-Environment Redundanz\n\nüõ°Ô∏è Security und Trust Management:\n‚Ä¢ Zero-Trust Networking zwischen On-Premises und Cloud PKI-Komponenten\n‚Ä¢ Encrypted Communication Channels f√ºr alle PKI-Daten√ºbertragungen zwischen Umgebungen\n‚Ä¢ Multi-Factor Authentication f√ºr Cross-Environment PKI-Operations\n‚Ä¢ Role-based Access Control mit einheitlichen Identity Providers √ºber Hybrid-Infrastrukturen\n‚Ä¢ Continuous Security Monitoring f√ºr alle PKI-Touchpoints in der Hybrid-Architektur\n\nüìä Governance und Compliance:\n‚Ä¢ Unified Policy Management f√ºr konsistente PKI-Governance √ºber alle Umgebungen\n‚Ä¢ Compliance Mapping f√ºr verschiedene regulatorische Anforderungen in Hybrid-Setups\n‚Ä¢ Audit Trail Consolidation f√ºr holistische Compliance-Berichte √ºber On-Premises und Cloud\n‚Ä¢ Risk Assessment Frameworks f√ºr Hybrid PKI-Architekturen\n‚Ä¢ Change Management Prozesse f√ºr koordinierte Updates √ºber verschiedene Umgebungen\n\nüöÄ Migration Best Practices:\n‚Ä¢ Phased Approach mit klaren Milestones und Rollback-Strategien f√ºr jede Migrationsphase\n‚Ä¢ Comprehensive Testing in Staging-Umgebungen vor Production Migration\n‚Ä¢ User Training und Change Management f√ºr Teams, die mit neuen Cloud PKI-Tools arbeiten\n‚Ä¢ Performance Benchmarking f√ºr Vergleich zwischen On-Premises und Cloud PKI-Performance\n‚Ä¢ Cost Optimization durch schrittweise Dekommissionierung von On-Premises Infrastrukturen\n\nüîß Technische Integration:\n‚Ä¢ API Gateway Integration f√ºr einheitliche PKI-Service Interfaces √ºber Hybrid-Umgebungen\n‚Ä¢ Load Balancing zwischen On-Premises und Cloud PKI-Services f√ºr optimale Performance\n‚Ä¢ Caching Strategien f√ºr h√§ufig verwendete Certificates in Hybrid-Architekturen\n‚Ä¢ Network Optimization f√ºr minimale Latenz zwischen On-Premises und Cloud PKI-Komponenten\n‚Ä¢ Monitoring und Alerting f√ºr End-to-End Visibility in Hybrid PKI-Operations"
      },
      {
        _type: 'object',
        _key: generateKey('faq', 8),
        question: 'Welche Monitoring- und Analytics-Funktionen bietet Cloud PKI f√ºr Observability und Performance-Optimierung?',
        answer: "Cloud PKI implementiert umfassende Monitoring- und Analytics-Funktionen, die speziell f√ºr die Anforderungen moderner Cloud-Umgebungen entwickelt wurden. Diese Observability-Features erm√∂glichen es Unternehmen, ihre PKI-Infrastrukturen proaktiv zu √ºberwachen, Performance zu optimieren und potenzielle Probleme fr√ºhzeitig zu erkennen.\n\nüìä Real-time Metriken und Dashboards:\n‚Ä¢ Comprehensive PKI-Metriken f√ºr Certificate Issuance Rates, Renewal Success Rates und Revocation Statistics\n‚Ä¢ Performance Metriken f√ºr API Response Times, Throughput und Error Rates √ºber alle PKI-Services\n‚Ä¢ Resource Utilization Monitoring f√ºr CPU, Memory und Storage Usage von PKI-Komponenten\n‚Ä¢ Custom Business Metrics f√ºr Certificate Usage Patterns, Cost per Certificate und ROI-Tracking\n‚Ä¢ Interactive Dashboards mit Drill-down Funktionalit√§ten f√ºr detaillierte Analyse\n\nüîç Distributed Tracing und Observability:\n‚Ä¢ End-to-End Tracing f√ºr komplexe PKI-Workflows √ºber Microservices und Multi-Cloud-Umgebungen\n‚Ä¢ Correlation IDs f√ºr Tracking von Certificate Requests durch alle PKI-Komponenten\n‚Ä¢ Span-basierte Performance Analysis f√ºr Identifikation von Bottlenecks in PKI-Operations\n‚Ä¢ Service Map Visualization f√ºr Abh√§ngigkeiten zwischen PKI-Services und Applications\n‚Ä¢ Error Tracking und Root Cause Analysis f√ºr PKI-bezogene Incidents\n\nü§ñ Predictive Analytics und Machine Learning:\n‚Ä¢ Certificate Expiry Prediction mit Machine Learning f√ºr proaktive Renewal Planning\n‚Ä¢ Anomaly Detection f√ºr ungew√∂hnliche Certificate Request Patterns oder Security Threats\n‚Ä¢ Capacity Planning basierend auf historischen Usage Patterns und Trend Analysis\n‚Ä¢ Performance Optimization Recommendations durch AI-basierte Analyse von PKI-Metriken\n‚Ä¢ Fraud Detection f√ºr verd√§chtige Certificate Requests oder unauthorized PKI-Operations\n\n‚ö†Ô∏è Intelligent Alerting und Incident Response:\n‚Ä¢ Smart Alerting mit Machine Learning f√ºr Reduktion von False Positives\n‚Ä¢ Escalation Policies f√ºr verschiedene Severity Levels von PKI-Incidents\n‚Ä¢ Integration mit PagerDuty, Slack und anderen Incident Response Tools\n‚Ä¢ Automated Remediation f√ºr h√§ufige PKI-Probleme wie Certificate Renewal Failures\n‚Ä¢ Contextual Alerts mit relevanten Troubleshooting Information und Runbooks\n\nüìà Business Intelligence und Reporting:\n‚Ä¢ Executive Dashboards f√ºr PKI-KPIs und Business Impact Metrics\n‚Ä¢ Cost Analysis und Optimization Recommendations f√ºr PKI-Resource Usage\n‚Ä¢ Compliance Reporting mit automated Generation von Audit Reports\n‚Ä¢ Usage Analytics f√ºr verschiedene Certificate Types, Applications und User Groups\n‚Ä¢ Trend Analysis f√ºr Long-term PKI Strategy Planning und Budget Forecasting\n\nüîß Integration mit Observability-Stacks:\n‚Ä¢ Native Prometheus Integration mit Custom Metrics und Grafana Dashboards\n‚Ä¢ ELK Stack Integration f√ºr Centralized Logging und Log Analysis\n‚Ä¢ Jaeger und Zipkin Integration f√ºr Distributed Tracing in Microservice-Architekturen\n‚Ä¢ DataDog, New Relic und andere APM Tool Integration f√ºr Unified Monitoring\n‚Ä¢ Custom Webhook Integration f√ºr Integration mit proprietary Monitoring Systems\n\nüõ†Ô∏è Operational Intelligence:\n‚Ä¢ Health Checks und Synthetic Monitoring f√ºr proaktive Service Availability Monitoring\n‚Ä¢ SLA Tracking und Reporting f√ºr PKI-Service Performance gegen definierte Targets\n‚Ä¢ Change Impact Analysis f√ºr Assessment von PKI-Konfigurations√§nderungen\n‚Ä¢ Capacity Utilization Forecasting f√ºr proaktive Scaling Decisions\n‚Ä¢ Performance Benchmarking gegen Industry Standards und Best Practices"
      }
    ]
    
    // Update the document with new FAQs
    const updatedFaqs = [...(existingDoc.faq || []), ...newFaqs]
    
    console.log(`Adding ${newFaqs.length} new FAQs to the document...`)
    const transaction = client.transaction()
    transaction.patch(existingDoc._id, {
      set: {
        faq: updatedFaqs
      }
    })
    
    await transaction.commit()
    console.log('‚úÖ FAQ batch 2 added successfully')
  } catch (error) {
    console.error('Error:', error)
    throw error
  }
}

run()
